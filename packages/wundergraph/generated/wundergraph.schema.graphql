# Code generated by "wunderctl"; DO NOT EDIT.

"""
The @removeNullVariables directive allows you to remove variables with null value from your GraphQL Query or Mutation Operations.

A potential use-case could be that you have a graphql upstream which is not accepting null values for variables.
By enabling this directive all variables with null values will be removed from upstream query.

query ($say: String, $name: String) @removeNullVariables {
	hello(say: $say, name: $name)
}

Directive will transform variables json and remove top level null values.
{ "say": null, "name": "world" }

So upstream will receive the following variables:

{ "name": "world" }
"""
directive @removeNullVariables on QUERY | MUTATION

directive @hooksVariable on VARIABLE_DEFINITION

directive @jsonSchema(
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  title: String
  """
  The value of both of these keywords MUST be a string.
  
  Both of these keywords can be used to decorate a user interface with
  information about the data produced by this user interface.  A title
  will preferably be short, whereas a description will provide
  explanation about the purpose of the instance described by this
  schema.
  """
  description: String
  """
  The value of "multipleOf" MUST be a number, strictly greater than 0.
  
  A numeric instance is valid only if division by this keyword's value
  results in an integer.
  """
  multipleOf: Int
  """
  The value of "maximum" MUST be a number, representing an inclusive
  upper limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is less than or exactly equal to "maximum".
  """
  maximum: Int
  """
  The value of "exclusiveMaximum" MUST be number, representing an
  exclusive upper limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly less than (not equal to) "exclusiveMaximum".
  """
  exclusiveMaximum: Int
  """
  The value of "minimum" MUST be a number, representing an inclusive
  lower limit for a numeric instance.
  
  If the instance is a number, then this keyword validates only if the
  instance is greater than or exactly equal to "minimum".
  """
  minimum: Int
  """
  The value of "exclusiveMinimum" MUST be number, representing an
  exclusive lower limit for a numeric instance.
  
  If the instance is a number, then the instance is valid only if it
  has a value strictly greater than (not equal to) "exclusiveMinimum".
  """
  exclusiveMinimum: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is less
  than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  """
  maxLength: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  A string instance is valid against this keyword if its length is
  greater than, or equal to, the value of this keyword.
  
  The length of a string instance is defined as the number of its
  characters as defined by RFC 7159 [RFC7159].
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minLength: Int
  """
  The value of this keyword MUST be a string.  This string SHOULD be a
  valid regular expression, according to the ECMA 262 regular
  expression dialect.
  
  A string instance is considered valid if the regular expression
  matches the instance successfully.  Recall: regular expressions are
  not implicitly anchored.
  """
  pattern: String
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "maxItems" if its size is less
  than, or equal to, the value of this keyword.
  """
  maxItems: Int
  """
  The value of this keyword MUST be a non-negative integer.
  
  An array instance is valid against "minItems" if its size is greater
  than, or equal to, the value of this keyword.
  
  Omitting this keyword has the same behavior as a value of 0.
  """
  minItems: Int
  """
  The value of this keyword MUST be a boolean.
  
  If this keyword has boolean value false, the instance validates
  successfully.  If it has boolean value true, the instance validates
  successfully if all of its elements are unique.
  
  Omitting this keyword has the same behavior as a value of false.
  """
  uniqueItems: Boolean
  commonPattern: COMMON_REGEX_PATTERN
  """Optional field to apply the JSON schema to"""
  on: String
) repeatable on VARIABLE_DEFINITION

directive @rbac(
  """the user must match all roles"""
  requireMatchAll: [WG_ROLE]
  """the user must match at least one of the roles"""
  requireMatchAny: [WG_ROLE]
  """the user must not match all of the roles"""
  denyMatchAll: [WG_ROLE]
  """the user must not match any of the roles"""
  denyMatchAny: [WG_ROLE]
) on QUERY | MUTATION | SUBSCRIPTION

"""
The @fromClaim directive sets the variable to the value retrieved from the given a claim.
Adding this directive makes the operation require authentication.
"""
directive @fromClaim(name: WG_CLAIM, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The directive @injectCurrentDateTime injects a DateTime string of the current date and time into the variable.
This variable MUST be a string compatible scalar. 

The default format, is: ISO 8601
If no format is chosen, the default format is used.
Custom formats are allowed by specifying a format conforming to the Golang specification for specifying a date time format.
"""
directive @injectCurrentDateTime(
  format: WunderGraphDateTimeFormat = ISO8601
  """
  customFormat must conform to the Golang specification for specifying a date time format
  """
  customFormat: String
  on: String = ""
) repeatable on VARIABLE_DEFINITION

"""
The directive @injectGeneratedUUID injects a generated UUID into the variable.
This variable MUST be a string.
At the same time, it removes the variable from the input definition,
disallowing the user to supply it.

This means, the UUID is 100% generated server-side and can be considered untempered.
"""
directive @injectGeneratedUUID(on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @internalOperation Directive marks an Operation as internal.
By doing so, the Operation is no longer accessible from the public API.
It can only be accessed by internal services, like hooks.
"""
directive @internalOperation on QUERY | MUTATION | SUBSCRIPTION

"""
The directive @injectEnvironmentVariable allows you to inject an environment variable into the variable definition.
"""
directive @injectEnvironmentVariable(name: String!, on: String = "") repeatable on VARIABLE_DEFINITION

"""
The @export directive instructs the Execution Planner to export the field during the execution into the variable of the 'as' argument.
As the execution is depth first, a field can only be used after it has been exported.
Additionally, a field can only be used after using the '_join' field or on a different data source.
It's not possible to export a field and use it in for the same data source.

Note that the @export directive only works on fields that return a single value.
It's not possible to export a list or object field.
"""
directive @export(
  """The argument 'as' is the name of the variable to export the field to."""
  as: String!
) on FIELD

"""
The directive @internal marks a variable definition as internal so that clients can't access it.
The field is also not visible in the public API.
It's only being used as an internal variable to export fields into.
"""
directive @internal on VARIABLE_DEFINITION

"""
The @transform directive allows to apply transformations to the response.
By applying the directive, the shape of the response can be altered,
which will also modify the JSON-Schema of the response.
That is, you will keep full type safety and code-generation for transformed fields.
"""
directive @transform(
  """
  Using the 'get' transformation allows you to extract a nested field using a JSON path.
  This is useful to unnest data, e.g. when using the '_join' field, which adds an extra layer of nesting.
  
  Example:
  
  query GetName {
      name: me @transform(get: "info.name") {
          info {
              name
          }
      }
  }
  
  Before the transformation, the resolve looks like this:
  
  {
      "name": {
          "info": {
              "name": "John Doe"
          }
      }
  }
  
  With the transformation applied, the response will be reshaped like this:
  
  {
      "name": "John Doe"
  }
  """
  get: String
) on FIELD

input db_NestedIntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

input db_IntFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntFilter
}

input db_NestedStringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringFilter
}

input db_StringFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringFilter
}

input db_NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_DateTimeFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeFilter
}

input db_PostListRelationFilter {
  every: db_PostWhereInput
  some: db_PostWhereInput
  none: db_PostWhereInput
}

input db_UserWhereInput {
  AND: db_UserWhereInput
  OR: [db_UserWhereInput]
  NOT: db_UserWhereInput
  id: db_IntFilter
  username: db_StringFilter
  created_at: db_DateTimeFilter
  Post: db_PostListRelationFilter
}

input db_UserRelationFilter {
  is: db_UserWhereInput
  isNot: db_UserWhereInput
}

input db_PostWhereInput {
  AND: db_PostWhereInput
  OR: [db_PostWhereInput]
  NOT: db_PostWhereInput
  id: db_IntFilter
  body: db_StringFilter
  author_id: db_IntFilter
  created_at: db_DateTimeFilter
  User: db_UserRelationFilter
}

enum db_SortOrder {
  asc
  desc
}

input db_PostOrderByRelationAggregateInput {
  _count: db_SortOrder
}

input db_UserOrderByWithRelationInput {
  id: db_SortOrder
  username: db_SortOrder
  created_at: db_SortOrder
  Post: db_PostOrderByRelationAggregateInput
}

input db_PostOrderByWithRelationInput {
  id: db_SortOrder
  body: db_SortOrder
  author_id: db_SortOrder
  created_at: db_SortOrder
  User: db_UserOrderByWithRelationInput
}

input db_PostWhereUniqueInput {
  id: Int
}

enum db_PostScalarFieldEnum {
  id
  body
  author_id
  created_at
}

type db_UserCountOutputType {
  Post: Int!
  _join: Query!
}

type db_User {
  id: Int!
  username: String!
  created_at: DateTime!
  Post(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): [db_Post]
  _count: db_UserCountOutputType!
  _join: Query!
}

type db_Post {
  id: Int!
  body: String!
  author_id: Int!
  created_at: DateTime!
  User: db_User!
  _join: Query!
}

type db_PostCountAggregateOutputType {
  id: Int!
  body: Int!
  author_id: Int!
  created_at: Int!
  _all: Int!
  _join: Query!
}

type db_PostAvgAggregateOutputType {
  id: Float
  author_id: Float
  _join: Query!
}

type db_PostSumAggregateOutputType {
  id: Int
  author_id: Int
  _join: Query!
}

type db_PostMinAggregateOutputType {
  id: Int
  body: String
  author_id: Int
  created_at: DateTime
  _join: Query!
}

type db_PostMaxAggregateOutputType {
  id: Int
  body: String
  author_id: Int
  created_at: DateTime
  _join: Query!
}

type db_AggregatePost {
  _count: db_PostCountAggregateOutputType
  _avg: db_PostAvgAggregateOutputType
  _sum: db_PostSumAggregateOutputType
  _min: db_PostMinAggregateOutputType
  _max: db_PostMaxAggregateOutputType
  _join: Query!
}

input db_PostCountOrderByAggregateInput {
  id: db_SortOrder
  body: db_SortOrder
  author_id: db_SortOrder
  created_at: db_SortOrder
}

input db_PostAvgOrderByAggregateInput {
  id: db_SortOrder
  author_id: db_SortOrder
}

input db_PostMaxOrderByAggregateInput {
  id: db_SortOrder
  body: db_SortOrder
  author_id: db_SortOrder
  created_at: db_SortOrder
}

input db_PostMinOrderByAggregateInput {
  id: db_SortOrder
  body: db_SortOrder
  author_id: db_SortOrder
  created_at: db_SortOrder
}

input db_PostSumOrderByAggregateInput {
  id: db_SortOrder
  author_id: db_SortOrder
}

input db_PostOrderByWithAggregationInput {
  id: db_SortOrder
  body: db_SortOrder
  author_id: db_SortOrder
  created_at: db_SortOrder
  _count: db_PostCountOrderByAggregateInput
  _avg: db_PostAvgOrderByAggregateInput
  _max: db_PostMaxOrderByAggregateInput
  _min: db_PostMinOrderByAggregateInput
  _sum: db_PostSumOrderByAggregateInput
}

input db_NestedFloatFilter {
  equals: Float
  in: [Float]
  notIn: [Float]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: db_NestedFloatFilter
}

input db_NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntWithAggregatesFilter
  _count: db_NestedIntFilter
  _avg: db_NestedFloatFilter
  _sum: db_NestedIntFilter
  _min: db_NestedIntFilter
  _max: db_NestedIntFilter
}

input db_IntWithAggregatesFilter {
  equals: Int
  in: [Int]
  notIn: [Int]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: db_NestedIntWithAggregatesFilter
  _count: db_NestedIntFilter
  _avg: db_NestedFloatFilter
  _sum: db_NestedIntFilter
  _min: db_NestedIntFilter
  _max: db_NestedIntFilter
}

input db_NestedStringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_StringWithAggregatesFilter {
  equals: String
  in: [String]
  notIn: [String]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: db_NestedStringWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedStringFilter
  _max: db_NestedStringFilter
}

input db_NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime]
  notIn: [DateTime]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: db_NestedDateTimeWithAggregatesFilter
  _count: db_NestedIntFilter
  _min: db_NestedDateTimeFilter
  _max: db_NestedDateTimeFilter
}

input db_PostScalarWhereWithAggregatesInput {
  AND: db_PostScalarWhereWithAggregatesInput
  OR: [db_PostScalarWhereWithAggregatesInput]
  NOT: db_PostScalarWhereWithAggregatesInput
  id: db_IntWithAggregatesFilter
  body: db_StringWithAggregatesFilter
  author_id: db_IntWithAggregatesFilter
  created_at: db_DateTimeWithAggregatesFilter
}

type db_PostGroupByOutputType {
  id: Int!
  body: String!
  author_id: Int!
  created_at: DateTime!
  _count: db_PostCountAggregateOutputType
  _avg: db_PostAvgAggregateOutputType
  _sum: db_PostSumAggregateOutputType
  _min: db_PostMinAggregateOutputType
  _max: db_PostMaxAggregateOutputType
  _join: Query!
}

input db_UserWhereUniqueInput {
  id: Int
  username: String
}

enum db_UserScalarFieldEnum {
  id
  username
  created_at
}

type db_UserCountAggregateOutputType {
  id: Int!
  username: Int!
  created_at: Int!
  _all: Int!
  _join: Query!
}

type db_UserAvgAggregateOutputType {
  id: Float
  _join: Query!
}

type db_UserSumAggregateOutputType {
  id: Int
  _join: Query!
}

type db_UserMinAggregateOutputType {
  id: Int
  username: String
  created_at: DateTime
  _join: Query!
}

type db_UserMaxAggregateOutputType {
  id: Int
  username: String
  created_at: DateTime
  _join: Query!
}

type db_AggregateUser {
  _count: db_UserCountAggregateOutputType
  _avg: db_UserAvgAggregateOutputType
  _sum: db_UserSumAggregateOutputType
  _min: db_UserMinAggregateOutputType
  _max: db_UserMaxAggregateOutputType
  _join: Query!
}

input db_UserCountOrderByAggregateInput {
  id: db_SortOrder
  username: db_SortOrder
  created_at: db_SortOrder
}

input db_UserAvgOrderByAggregateInput {
  id: db_SortOrder
}

input db_UserMaxOrderByAggregateInput {
  id: db_SortOrder
  username: db_SortOrder
  created_at: db_SortOrder
}

input db_UserMinOrderByAggregateInput {
  id: db_SortOrder
  username: db_SortOrder
  created_at: db_SortOrder
}

input db_UserSumOrderByAggregateInput {
  id: db_SortOrder
}

input db_UserOrderByWithAggregationInput {
  id: db_SortOrder
  username: db_SortOrder
  created_at: db_SortOrder
  _count: db_UserCountOrderByAggregateInput
  _avg: db_UserAvgOrderByAggregateInput
  _max: db_UserMaxOrderByAggregateInput
  _min: db_UserMinOrderByAggregateInput
  _sum: db_UserSumOrderByAggregateInput
}

input db_UserScalarWhereWithAggregatesInput {
  AND: db_UserScalarWhereWithAggregatesInput
  OR: [db_UserScalarWhereWithAggregatesInput]
  NOT: db_UserScalarWhereWithAggregatesInput
  id: db_IntWithAggregatesFilter
  username: db_StringWithAggregatesFilter
  created_at: db_DateTimeWithAggregatesFilter
}

type db_UserGroupByOutputType {
  id: Int!
  username: String!
  created_at: DateTime!
  _count: db_UserCountAggregateOutputType
  _avg: db_UserAvgAggregateOutputType
  _sum: db_UserSumAggregateOutputType
  _min: db_UserMinAggregateOutputType
  _max: db_UserMaxAggregateOutputType
  _join: Query!
}

type Query {
  db_findFirstPost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): db_Post
  db_findManyPost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int, distinct: [db_PostScalarFieldEnum]): [db_Post]!
  db_aggregatePost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithRelationInput], cursor: db_PostWhereUniqueInput, take: Int, skip: Int): db_AggregatePost!
  db_groupByPost(where: db_PostWhereInput, orderBy: [db_PostOrderByWithAggregationInput], by: [db_PostScalarFieldEnum]!, having: db_PostScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_PostGroupByOutputType]!
  db_findUniquePost(where: db_PostWhereUniqueInput!): db_Post
  db_findFirstUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int, distinct: [db_UserScalarFieldEnum]): db_User
  db_findManyUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int, distinct: [db_UserScalarFieldEnum]): [db_User]!
  db_aggregateUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithRelationInput], cursor: db_UserWhereUniqueInput, take: Int, skip: Int): db_AggregateUser!
  db_groupByUser(where: db_UserWhereInput, orderBy: [db_UserOrderByWithAggregationInput], by: [db_UserScalarFieldEnum]!, having: db_UserScalarWhereWithAggregatesInput, take: Int, skip: Int): [db_UserGroupByOutputType]!
  db_findUniqueUser(where: db_UserWhereUniqueInput!): db_User
  db_queryRaw(query: String!, parameters: [String]): [_Row!]!
  db_queryRawJSON(query: String!, parameters: [String]): JSON
}

input db_UserCreateWithoutPostInput {
  username: String!
  created_at: DateTime
}

input db_UserCreateOrConnectWithoutPostInput {
  where: db_UserWhereUniqueInput!
  create: db_UserCreateWithoutPostInput!
}

input db_UserCreateNestedOneWithoutPostInput {
  create: db_UserCreateWithoutPostInput
  connectOrCreate: db_UserCreateOrConnectWithoutPostInput
  connect: db_UserWhereUniqueInput
}

input db_PostCreateInput {
  body: String!
  created_at: DateTime
  User: db_UserCreateNestedOneWithoutPostInput!
}

input db_StringFieldUpdateOperationsInput {
  set: String
}

input db_DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input db_UserUpdateWithoutPostInput {
  username: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
}

input db_UserUpsertWithoutPostInput {
  update: db_UserUpdateWithoutPostInput!
  create: db_UserCreateWithoutPostInput!
}

input db_UserUpdateOneRequiredWithoutPostInput {
  create: db_UserCreateWithoutPostInput
  connectOrCreate: db_UserCreateOrConnectWithoutPostInput
  upsert: db_UserUpsertWithoutPostInput
  connect: db_UserWhereUniqueInput
  update: db_UserUpdateWithoutPostInput
}

input db_PostUpdateInput {
  body: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  User: db_UserUpdateOneRequiredWithoutPostInput
}

input db_PostUpdateManyMutationInput {
  body: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
}

type db_AffectedRowsOutput {
  count: Int!
  _join: Query!
}

input db_PostCreateWithoutUserInput {
  body: String!
  created_at: DateTime
}

input db_PostCreateOrConnectWithoutUserInput {
  where: db_PostWhereUniqueInput!
  create: db_PostCreateWithoutUserInput!
}

input db_PostCreateNestedManyWithoutUserInput {
  create: db_PostCreateWithoutUserInput
  connectOrCreate: db_PostCreateOrConnectWithoutUserInput
  connect: db_PostWhereUniqueInput
}

input db_UserCreateInput {
  username: String!
  created_at: DateTime
  Post: db_PostCreateNestedManyWithoutUserInput
}

input db_PostUpdateWithoutUserInput {
  body: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
}

input db_PostUpsertWithWhereUniqueWithoutUserInput {
  where: db_PostWhereUniqueInput!
  update: db_PostUpdateWithoutUserInput!
  create: db_PostCreateWithoutUserInput!
}

input db_PostUpdateWithWhereUniqueWithoutUserInput {
  where: db_PostWhereUniqueInput!
  data: db_PostUpdateWithoutUserInput!
}

input db_PostScalarWhereInput {
  AND: db_PostScalarWhereInput
  OR: [db_PostScalarWhereInput]
  NOT: db_PostScalarWhereInput
  id: db_IntFilter
  body: db_StringFilter
  author_id: db_IntFilter
  created_at: db_DateTimeFilter
}

input db_PostUpdateManyWithWhereWithoutUserInput {
  where: db_PostScalarWhereInput!
  data: db_PostUpdateManyMutationInput!
}

input db_PostUpdateManyWithoutUserInput {
  create: db_PostCreateWithoutUserInput
  connectOrCreate: db_PostCreateOrConnectWithoutUserInput
  upsert: db_PostUpsertWithWhereUniqueWithoutUserInput
  set: db_PostWhereUniqueInput
  disconnect: db_PostWhereUniqueInput
  delete: db_PostWhereUniqueInput
  connect: db_PostWhereUniqueInput
  update: db_PostUpdateWithWhereUniqueWithoutUserInput
  updateMany: db_PostUpdateManyWithWhereWithoutUserInput
  deleteMany: db_PostScalarWhereInput
}

input db_UserUpdateInput {
  username: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
  Post: db_PostUpdateManyWithoutUserInput
}

input db_UserUpdateManyMutationInput {
  username: db_StringFieldUpdateOperationsInput
  created_at: db_DateTimeFieldUpdateOperationsInput
}

type Mutation {
  db_createOnePost(data: db_PostCreateInput!): db_Post
  db_upsertOnePost(where: db_PostWhereUniqueInput!, create: db_PostCreateInput!, update: db_PostUpdateInput!): db_Post
  db_deleteOnePost(where: db_PostWhereUniqueInput!): db_Post
  db_updateOnePost(data: db_PostUpdateInput!, where: db_PostWhereUniqueInput!): db_Post
  db_updateManyPost(data: db_PostUpdateManyMutationInput!, where: db_PostWhereInput): db_AffectedRowsOutput
  db_deleteManyPost(where: db_PostWhereInput): db_AffectedRowsOutput
  db_createOneUser(data: db_UserCreateInput!): db_User
  db_upsertOneUser(where: db_UserWhereUniqueInput!, create: db_UserCreateInput!, update: db_UserUpdateInput!): db_User
  db_deleteOneUser(where: db_UserWhereUniqueInput!): db_User
  db_updateOneUser(data: db_UserUpdateInput!, where: db_UserWhereUniqueInput!): db_User
  db_updateManyUser(data: db_UserUpdateManyMutationInput!, where: db_UserWhereInput): db_AffectedRowsOutput
  db_deleteManyUser(where: db_UserWhereInput): db_AffectedRowsOutput
  db_executeRaw(query: String!, parameters: [String]): Int!
}

scalar DateTime

scalar JSON

scalar UUID

scalar BigInt

scalar db_Bytes

type _Row {
  ID: ID!
  Int: Int!
  Float: Float!
  String: String!
  Boolean: Boolean!
  DateTime: DateTime!
  JSON: JSON!
  Object: _Row!
  Array: [_Row!]!
  OptionalID: ID
  OptionalInt: Int
  OptionalFloat: Float
  OptionalString: String
  OptionalBoolean: Boolean
  OptionalDateTime: DateTime
  OptionalJSON: JSON
  OptionalObject: _Row
  OptionalArray: [_Row!]
  _join: Query!
}

enum COMMON_REGEX_PATTERN {
  EMAIL
  DOMAIN
}

enum WG_ROLE {
  admin
  user
}

"""Well known claims - https://www.iana.org/assignments/jwt/jwt.xhtml"""
enum WG_CLAIM {
  """iss"""
  ISSUER
  """deprecated alias for ISSUER"""
  PROVIDER
  """sub"""
  SUBJECT
  """alias for sub"""
  USERID
  """name"""
  NAME
  """given_name"""
  GIVEN_NAME
  """family_name"""
  FAMILY_NAME
  """middle_name"""
  MIDDLE_NAME
  """nickname"""
  NICKNAME
  """preferred_username"""
  PREFERRED_USERNAME
  """profile"""
  PROFILE
  """picture"""
  PICTURE
  """website"""
  WEBSITE
  """email"""
  EMAIL
  """email_verified"""
  EMAIL_VERIFIED
  """gender"""
  GENDER
  """birthdate"""
  BIRTH_DATE
  """zoneinfo"""
  ZONE_INFO
  """locale"""
  LOCALE
  """location"""
  LOCATION
}

enum WunderGraphDateTimeFormat {
  """2006-01-02T15:04:05-0700"""
  ISO8601
  """Mon Jan _2 15:04:05 2006"""
  ANSIC
  """Mon Jan _2 15:04:05 MST 2006"""
  UnixDate
  """Mon Jan 02 15:04:05 -0700 2006"""
  RubyDate
  """02 Jan 06 15:04 MST"""
  RFC822
  """02 Jan 06 15:04 -0700"""
  RFC822Z
  """Monday, 02-Jan-06 15:04:05 MST"""
  RFC850
  """Mon, 02 Jan 2006 15:04:05 MST"""
  RFC1123
  """Mon, 02 Jan 2006 15:04:05 -0700"""
  RFC1123Z
  """2006-01-02T15:04:05Z07:00"""
  RFC3339
  """2006-01-02T15:04:05.999999999Z07:00"""
  RFC3339Nano
  """3:04PM"""
  Kitchen
  """Jan _2 15:04:05"""
  Stamp
  """Jan _2 15:04:05.000"""
  StampMilli
  """Jan _2 15:04:05.000000"""
  StampMicro
  """Jan _2 15:04:05.000000000"""
  StampNano
}